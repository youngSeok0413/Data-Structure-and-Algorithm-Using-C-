  main.cpp
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(84,20): warning C4018: '<': signed 또는 unsigned가 일치하지 않습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(179): message : 컴파일되는 함수 템플릿 인스턴스화 'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>> linear_time_select<int>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,size_t)'에 대한 참조를 확인하세요.
          with
          [
              _Ty=int
          ]
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(89,12): warning C4018: '<': signed 또는 unsigned가 일치하지 않습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(96,13): warning C4018: '<': signed 또는 unsigned가 일치하지 않습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): error C3867: 'std::vector<int,std::allocator<int>>::size': 비표준 구문입니다. '&'를 사용하여 멤버 포인터를 만드세요.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(103,36): error C2446: '==': 'int'에서 'unsigned __int64 (__cdecl std::vector<int,std::allocator<int>>::* )(void) noexcept const'(으)로 변환되지 않았습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(103,39): message : 정수 계열 값에서 멤버 포인터 값으로의 변환이 없습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): error C3867: 'std::vector<int,std::allocator<int>>::begin': 비표준 구문입니다. '&'를 사용하여 멤버 포인터를 만드세요.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): error C3536: 'median_of_medians': 초기화되기 전에 사용할 수 없습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(106,25): error C2664: 'auto partition_using_given_pivot<int>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>)': 인수 3을(를) 'int'에서 'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>'(으)로 변환할 수 없습니다.
          with
          [
              _Ty=int
          ]
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): message : 소스 형식을 가져올 수 있는 생성자가 없거나 생성자 오버로드 확인이 모호합니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(53,6): message : 'partition_using_given_pivot' 선언을 참조하십시오.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): error C3536: 'partition_iter': 초기화되기 전에 사용할 수 없습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(107,17): error C2672: 'std::distance': 일치하는 오버로드된 함수가 없습니다.
D:\SDK\Visual Studio\VC\Tools\MSVC\14.33.31629\include\xutility(1596,45): message : 'iterator_traits<_Iter>::difference_type std::distance(_InIt,_InIt)'일 수 있습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(107,17): message : 'iterator_traits<_Iter>::difference_type std::distance(_InIt,_InIt)': 템플릿 매개 변수 '_InIt'이(가) 모호합니다.
D:\SDK\Visual Studio\VC\Tools\MSVC\14.33.31629\include\xutility(1596): message : 'std::distance' 선언을 참조하십시오.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): message : 'int'일 수 있습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): message : 또는      'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>'
          with
          [
              _Ty=int
          ]
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(107,17): message : 'iterator_traits<_Iter>::difference_type std::distance(_InIt,_InIt)': 'int'에서 '_InIt'에 대한 템플릿 인수를 추론할 수 없습니다.
D:\SDK\Visual Studio\VC\Tools\MSVC\14.33.31629\include\xutility(1596): message : 'std::distance' 선언을 참조하십시오.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): error C3536: 'k': 초기화되기 전에 사용할 수 없습니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(110,4): error C2440: 'return': 'int'에서 'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>'(으)로 변환할 수 없습니다.
          with
          [
              _Ty=int
          ]
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): message : 소스 형식을 가져올 수 있는 생성자가 없거나 생성자 오버로드 확인이 모호합니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(112,11): error C2664: 'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>> linear_time_select<int>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,size_t)': 인수 2을(를) 'int'에서 'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>'(으)로 변환할 수 없습니다.
          with
          [
              _Ty=int
          ]
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): message : 소스 형식을 가져올 수 있는 생성자가 없거나 생성자 오버로드 확인이 모호합니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(79,35): message : 'linear_time_select' 선언을 참조하십시오.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(114,11): error C2664: 'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>> linear_time_select<int>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>,size_t)': 인수 1을(를) 'int'에서 'std::_Vector_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>'(으)로 변환할 수 없습니다.
          with
          [
              _Ty=int
          ]
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(81,1): message : 소스 형식을 가져올 수 있는 생성자가 없거나 생성자 오버로드 확인이 모호합니다.
D:\Work\Data-Structure-and-Algorithm-Using-C-\4장 분할 정복\Exercise 21\Exercise 21\main.cpp(79,35): message : 'linear_time_select' 선언을 참조하십시오.
